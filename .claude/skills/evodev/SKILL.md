---
name: evodev
description: EvoDev 프레임워크를 사용한 반복적 소프트웨어 개발. 복잡한 프로젝트를 기능 단위로 분해하고 체계적으로 구현합니다. 새로운 앱 개발, 대규모 기능 추가, 복잡한 리팩토링 등 다단계 개발 작업에 사용하세요.
---

# EvoDev: 기능-중심 반복 개발 프레임워크

EvoDev는 복잡한 소프트웨어 개발 프로젝트를 체계적으로 진행하기 위한 프레임워크입니다.
기능-중심 개발(Feature-Driven Development) 방법론을 기반으로 하며, **Figma MCP 연동**을 통해
UI 개발 시 디자인 시스템을 효율적으로 마이그레이션할 수 있습니다.

## 프레임워크 개요

```
┌─────────────────────────────────────────────────────────┐
│                    Phase 1: 전체 설계                    │
│  ┌─────────────────┐    ┌─────────────────────────────┐ │
│  │  비즈니스 분석   │ -> │      아키텍처 설계          │ │
│  │  (요구사항 정리) │    │  (데이터 모델, UI 구조)     │ │
│  └─────────────────┘    └─────────────────────────────┘ │
│                              │                          │
│                              ▼                          │
│              ┌─────────────────────────────┐            │
│              │    디자인 시스템 연동        │            │
│              │  (Figma MCP 설정, 전략 수립) │            │
│              └─────────────────────────────┘            │
└─────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────┐
│                  Phase 2: 기능 맵 생성                   │
│  ┌─────────────────┐    ┌─────────────────────────────┐ │
│  │   기능 추출     │ -> │      기능 계획              │ │
│  │  (작은 단위로)  │    │  (의존성 분석, 순서 결정)   │ │
│  └─────────────────┘    └─────────────────────────────┘ │
│                              │                          │
│                              ▼                          │
│              ┌─────────────────────────────┐            │
│              │    Figma 노드 매핑           │            │
│              │  (기능별 UI 컴포넌트 연결)   │            │
│              └─────────────────────────────┘            │
│                                                         │
│                    Feature DAG 생성                     │
│         ┌───┐     ┌───┐     ┌───┐                      │
│         │ A │ --> │ B │ --> │ D │                      │
│         └───┘     └───┘     └───┘                      │
│           │         │                                   │
│           ▼         ▼                                   │
│         ┌───┐     ┌───┐                                │
│         │ C │ --> │ E │                                │
│         └───┘     └───┘                                │
└─────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────┐
│               Phase 3: 반복적 기능 개발                  │
│                                                         │
│    ┌──────────┐   ┌──────────┐   ┌──────────┐          │
│    │  설계    │-->│  구현    │-->│ 디버깅   │──┐       │
│    └──────────┘   └──────────┘   └──────────┘  │       │
│         ▲              │                       │       │
│         │              ▼                       │       │
│         │     ┌──────────────────┐             │       │
│         │     │ Figma 마이그레이션│             │       │
│         │     │ (UI 기능 구현 시) │             │       │
│         │     └──────────────────┘             │       │
│         └──────────────────────────────────────┘       │
│                    (기능별 반복)                        │
└─────────────────────────────────────────────────────────┘
```

## Phase 1: 전체 설계 구성

### 1.1 비즈니스 분석

사용자 요구사항을 구조화된 문서로 변환합니다.

**수행 작업:**
1. 사용자 요구사항 수집 및 명확화
2. 핵심 기능과 부가 기능 구분
3. 사용자 스토리 작성
4. 제약 조건 및 비기능 요구사항 정리

**산출물 형식:**
```markdown
## 프로젝트 개요
- 프로젝트명:
- 목적:
- 대상 사용자:

## 핵심 요구사항
1. [요구사항 1]
   - 상세 설명
   - 수용 기준

## 비기능 요구사항
- 성능:
- 보안:
- 확장성:

## 제약 조건
- 기술 스택:
- 일정:
- 기타:
```

### 1.2 아키텍처 설계

전체적인 시스템 청사진을 작성합니다.

**수행 작업:**
1. 기술 스택 결정
2. 데이터 모델 설계
3. API 구조 설계
4. UI/UX 구조 설계
5. 디렉토리 구조 정의

**산출물 형식:**
```markdown
## 기술 스택
- Frontend:
- Backend:
- Database:
- Infrastructure:

## 데이터 모델
[엔티티 관계도 또는 스키마]

## API 구조
[주요 엔드포인트 목록]

## 디렉토리 구조
[프로젝트 폴더 구조]
```

### 1.3 디자인 시스템 연동 (UI 개발 시)

UI가 포함된 프로젝트에서 Figma를 디자인 도구로 사용하는 경우,
Figma MCP를 통해 디자인 데이터를 프로젝트에 효율적으로 마이그레이션합니다.

**수행 작업:**
1. Figma MCP 연동 여부 확인
2. Figma 파일/프로젝트 구조 파악
3. 마이그레이션 전략 수립 (사용자와 협의)
4. 디자인 토큰 및 컴포넌트 변환 규칙 정의

**사용자에게 질문할 사항:**
```markdown
## Figma 마이그레이션 전략 수립

Figma MCP가 연동되어 있습니다. 디자인 데이터를 프로젝트에
적용하는 방식을 결정해야 합니다.

### 질문 1: 컴포넌트 변환 방식
1. **직접 변환**: Figma 컴포넌트를 프로젝트 컴포넌트로 1:1 변환
2. **참조 변환**: Figma를 참고하여 기존 UI 라이브러리 컴포넌트 활용
3. **하이브리드**: 핵심 컴포넌트는 직접 변환, 나머지는 라이브러리 활용

### 질문 2: 스타일 추출 방식
1. **디자인 토큰**: 색상, 간격, 타이포그래피를 토큰으로 추출
2. **CSS 직접 생성**: Figma 스타일을 CSS/SCSS로 직접 변환
3. **Tailwind 클래스**: Figma 스타일을 Tailwind 클래스로 매핑

### 질문 3: 레이아웃 구현 방식
1. **Flexbox/Grid**: Figma Auto Layout을 CSS Flexbox/Grid로 변환
2. **절대 위치**: Figma 좌표를 기반으로 절대 위치 지정
3. **반응형 우선**: Figma를 참고하되 반응형 레이아웃 직접 설계

### 질문 4: 에셋 관리 방식
1. **SVG 인라인**: 아이콘/그래픽을 SVG 컴포넌트로 변환
2. **이미지 다운로드**: PNG/JPG로 내보내어 assets 폴더에 저장
3. **아이콘 라이브러리**: 유사한 아이콘 라이브러리로 대체
```

**산출물 형식:**
```markdown
## 디자인 시스템 연동 설정

### Figma 프로젝트 정보
- Figma 파일 URL:
- 주요 페이지/프레임:

### 마이그레이션 전략
- 컴포넌트 변환: [선택한 방식]
- 스타일 추출: [선택한 방식]
- 레이아웃 구현: [선택한 방식]
- 에셋 관리: [선택한 방식]

### 디자인 토큰 (해당 시)
- 색상 팔레트:
- 타이포그래피:
- 간격 시스템:

### 변환 규칙
| Figma 요소 | 프로젝트 변환 |
|-----------|--------------|
| [Frame명] | [컴포넌트명] |
```

---

## Phase 2: 기능 맵 생성

### 2.1 기능 추출

요구사항을 작은 사용자-가치 기능으로 분해합니다.

**기능 분해 원칙:**
- 각 기능은 독립적으로 테스트 가능해야 함
- 각 기능은 사용자에게 가치를 제공해야 함
- 기능 크기는 하루 이내 구현 가능한 수준으로

**기능 정의 형식:**
```markdown
### Feature: [기능명]
- **ID**: F001
- **설명**: [기능 설명]
- **사용자 스토리**: As a [사용자], I want [기능] so that [가치]
- **수용 기준**:
  - [ ] 기준 1
  - [ ] 기준 2
- **의존성**: [선행 기능 ID 목록]
```

### 2.2 기능 계획 (DAG 생성)

기능 간 의존성을 분석하고 개발 순서를 결정합니다.

**각 기능 노드의 3계층 정보:**

| 계층 | 내용 |
|------|------|
| 비즈니스 계층 | 기능 범위, 사용자 스토리 |
| 설계 계층 | 관련 UI 컴포넌트, 데이터 엔티티 |
| 구현 계층 | 필요한 파일, 코드 변경사항 |

**의존성 분석 기준:**
1. 데이터 의존성: 기능 B가 기능 A의 데이터 모델을 사용
2. UI 의존성: 기능 B가 기능 A의 컴포넌트를 재사용
3. API 의존성: 기능 B가 기능 A의 API를 호출

**TodoWrite 활용:**
```
기능 DAG를 TodoWrite 도구로 관리합니다:
- pending: 대기 중 (의존성 미충족)
- in_progress: 개발 중
- completed: 완료
```

### 2.3 Figma 노드 매핑 (UI 기능 시)

UI가 필요한 각 기능에 대해 Figma 노드를 매핑합니다.
이를 통해 구현 시 정확한 디자인 참조가 가능합니다.

**수행 작업:**
1. 각 기능별 필요한 UI 화면 식별
2. Figma MCP를 통해 해당 화면의 노드 ID 조회
3. 기능-Figma 노드 매핑 테이블 작성
4. 컴포넌트 재사용 가능성 분석

**Figma MCP 활용:**
```markdown
## Figma 노드 조회 방법

1. Figma MCP의 get_file 또는 get_node 도구 사용
2. 페이지/프레임 구조 탐색
3. 필요한 노드 ID 기록
4. 컴포넌트 인스턴스 관계 파악
```

**기능별 Figma 매핑 형식:**
```markdown
### Feature: [기능명]
- **ID**: F###
- **UI 요구사항**: [화면 설명]

#### Figma 노드 매핑
| UI 요소 | Figma 노드 ID | Figma 경로 | 비고 |
|--------|--------------|-----------|------|
| 메인 화면 | node-id-1 | Page/Frame/Component | 전체 레이아웃 |
| 버튼 | node-id-2 | Page/Frame/Button | Primary 스타일 |
| 입력 필드 | node-id-3 | Page/Frame/Input | 기본 상태 |

#### 재사용 컴포넌트
- [ ] 공통 Button 컴포넌트 (F001에서 생성)
- [ ] 신규 Modal 컴포넌트 (이 기능에서 생성)
```

**매핑 시 사용자 확인 사항:**
```markdown
## Figma 노드 매핑 확인

기능 [F###]의 UI를 구현하기 위해 다음 Figma 노드를 매핑했습니다.

| 화면/컴포넌트 | Figma 위치 |
|-------------|-----------|
| [설명] | [Figma 경로] |

### 확인 질문
1. 매핑된 Figma 노드가 정확한가요?
2. 추가로 참조해야 할 디자인이 있나요?
3. 디자인에서 변경이 필요한 부분이 있나요?
```

---

## Phase 3: 반복적 기능 개발

각 기능을 순서대로 개발합니다. 하나의 기능이 완료되면 다음 기능으로 진행합니다.

### 3.1 기능별 상세 설계

**수행 작업:**
1. 구현에 필요한 파일 목록 작성
2. 각 파일의 변경 사항 정의
3. 테스트 계획 수립

### 3.2 구현

**개발 루프:**
```
┌─────────────────────────────────────────┐
│  1. 코드 작성                           │
│     - 기존 코드 분석                    │
│     - 새 코드 구현                      │
│     - 기존 코드 수정                    │
├─────────────────────────────────────────┤
│  2. 빌드 및 테스트                      │
│     - 자동 빌드 실행                    │
│     - 에러 확인                         │
├─────────────────────────────────────────┤
│  3. 디버깅 (필요시)                     │
│     - 에러 분석                         │
│     - 수정 및 재시도                    │
└─────────────────────────────────────────┘
```

**코드 품질 원칙:**
- 기존 코드 스타일과 일관성 유지
- 불필요한 복잡성 피하기
- 변경 범위 최소화

### 3.3 Figma 마이그레이션 (UI 구현 시)

UI 기능 구현 시, Phase 1에서 수립한 마이그레이션 전략과
Phase 2에서 매핑한 Figma 노드를 활용하여 디자인을 구현합니다.

**Figma 마이그레이션 워크플로우:**
```
┌─────────────────────────────────────────────────────────┐
│              Figma 마이그레이션 프로세스                 │
│                                                         │
│  1. Figma 노드 조회                                     │
│     └─> MCP로 매핑된 노드 데이터 가져오기               │
│                                                         │
│  2. 사용자 확인                                         │
│     └─> 구현 방향 확인 질문                             │
│                                                         │
│  3. 컴포넌트 생성                                       │
│     └─> 합의된 전략에 따라 구현                         │
│                                                         │
│  4. 스타일 적용                                         │
│     └─> 디자인 토큰/CSS 적용                           │
│                                                         │
│  5. 검토 요청                                           │
│     └─> 사용자에게 결과 확인 요청                       │
└─────────────────────────────────────────────────────────┘
```

**구현 전 사용자 확인:**
```markdown
## [F###] UI 구현 방향 확인

Figma 노드 [node-id]를 기반으로 [컴포넌트명]을 구현하려고 합니다.

### Figma 디자인 분석
- 레이아웃: [Auto Layout / Fixed]
- 주요 요소: [요소 목록]
- 상태: [default, hover, active 등]

### 구현 계획
Phase 1에서 합의한 전략에 따라:
- 컴포넌트: [직접 변환 / 참조 변환]
- 스타일: [디자인 토큰 / CSS / Tailwind]
- 레이아웃: [Flexbox / Grid / 반응형]

### 확인 사항
1. 이 방향으로 진행해도 될까요?
2. 디자인에서 수정이 필요한 부분이 있나요?
3. 추가로 고려해야 할 상태(hover, disabled 등)가 있나요?
```

**Figma 데이터 활용:**
```typescript
// Figma MCP 응답 데이터 활용 예시
// 1. 노드 구조 분석
const figmaNode = await mcp_figma.get_node({ nodeId: "node-id" });

// 2. 스타일 추출 (사용자 전략에 따라)
// - 색상: fills, strokes
// - 타이포그래피: style, fontSize, fontFamily
// - 간격: padding, itemSpacing
// - 레이아웃: layoutMode, primaryAxisAlignItems

// 3. 컴포넌트 생성
// 사용자가 선택한 방식으로 구현
```

**구현 후 사용자 확인:**
```markdown
## [F###] UI 구현 결과 확인

[컴포넌트명]을 구현했습니다.

### 변경 파일
- `src/components/[Component].tsx` - 컴포넌트 생성
- `src/styles/[component].css` - 스타일 적용

### Figma 대비 변경사항
| 항목 | Figma 원본 | 구현 결과 | 사유 |
|-----|-----------|----------|-----|
| [항목] | [원본값] | [구현값] | [이유] |

### 확인 질문
1. 구현 결과가 디자인과 일치하나요?
2. 수정이 필요한 부분이 있나요?
3. 다음 기능으로 진행해도 될까요?
```

### 3.4 기능 완료 체크리스트

- [ ] 모든 수용 기준 충족
- [ ] 빌드 성공
- [ ] 테스트 통과
- [ ] 기존 기능에 영향 없음
- [ ] (UI 기능) Figma 디자인과 일치 확인

---

## 실행 가이드

### 스킬 시작하기

1. **프로젝트 시작 시 선언:**
   "EvoDev 방법론으로 [프로젝트/기능]을 개발하겠습니다"

2. **각 Phase 순차 진행:**
   - Phase 1 산출물 확정 후 Phase 2 진행
   - Phase 2 완료 후 Phase 3 반복 시작

3. **진행 상황 추적:**
   - TodoWrite로 기능별 진행 상황 관리
   - 각 기능 완료 시 명시적으로 체크

### 유의사항

1. **점진적 세부화**: 초기에 모든 것을 완벽하게 설계하려 하지 않음
2. **빠른 피드백**: 각 기능마다 빌드/테스트로 즉시 검증
3. **의존성 존중**: DAG 순서를 준수하여 개발
4. **범위 제한**: 현재 기능에 집중, 다른 기능은 다음 반복에서
5. **Figma 연동 시**: 매 UI 구현 전후로 사용자 확인 필수

---

## 참고: 역할 요약

| 역할 | Phase | 책임 |
|------|-------|------|
| 비즈니스 분석가 | 1 | 요구사항 정리, 문서화 |
| 아키텍트 | 1 | 시스템 설계, 기술 결정 |
| 디자인 시스템 설계자 | 1 | Figma 연동, 마이그레이션 전략 수립 |
| 기능 추출기 | 2 | 요구사항을 기능 단위로 분해 |
| 기능 계획자 | 2 | 의존성 분석, 개발 순서 결정 |
| UI 매퍼 | 2 | 기능별 Figma 노드 매핑 |
| 수석 프로그래머 | 3 | 기능별 상세 설계 |
| 프로그래머 | 3 | 코드 구현, 디버깅 |
| UI 개발자 | 3 | Figma 마이그레이션, UI 구현 |

모든 역할은 Claude가 수행하며, 각 Phase에서 해당 역할의 관점으로 작업합니다.

---

## Figma MCP 연동 가이드

### MCP 연결 확인

프로젝트 시작 시 Figma MCP 연동 여부를 확인합니다:

```markdown
## 디자인 도구 확인

UI가 포함된 프로젝트입니다. 다음을 확인해주세요:

1. **Figma MCP가 연동되어 있나요?**
   - 예 → Figma 마이그레이션 전략을 수립합니다
   - 아니오 → 수동으로 디자인을 참조합니다

2. **Figma 파일 URL을 공유해주세요**
   - MCP를 통해 디자인 구조를 파악합니다

3. **디자인 시스템이 정의되어 있나요?**
   - 예 → 기존 토큰/컴포넌트를 활용합니다
   - 아니오 → Figma에서 추출하여 생성합니다
```

### 주요 Figma MCP 도구

| 도구 | 용도 | 사용 시점 |
|-----|------|---------|
| `get_file` | 파일 전체 구조 조회 | Phase 1 - 구조 파악 |
| `get_node` | 특정 노드 상세 조회 | Phase 2 - 노드 매핑 |
| `get_styles` | 스타일 정보 조회 | Phase 1 - 토큰 추출 |
| `get_components` | 컴포넌트 목록 조회 | Phase 2 - 재사용 분석 |
| `get_images` | 이미지 에셋 다운로드 | Phase 3 - 에셋 적용 |

### 사용자 피드백 루프

Figma 연동 시 **사용자 중심 피드백 루프**를 유지합니다:

```
┌──────────────────────────────────────────────────────────┐
│                   피드백 루프                            │
│                                                          │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐              │
│  │ AI 분석 │ -> │ 질문    │ -> │ 사용자  │              │
│  │ & 제안  │    │ 제시    │    │ 피드백  │              │
│  └─────────┘    └─────────┘    └─────────┘              │
│       ▲                              │                   │
│       └──────────────────────────────┘                   │
│              (합의될 때까지 반복)                        │
└──────────────────────────────────────────────────────────┘

적용 시점:
- Phase 1: 마이그레이션 전략 수립 시
- Phase 2: Figma 노드 매핑 시
- Phase 3: 각 UI 컴포넌트 구현 전후
```

### 마이그레이션 전략 유형

**전략 A: 정밀 변환**
- Figma 디자인을 최대한 정확하게 구현
- 픽셀 단위 정확성 중시
- 디자인 시스템이 확정된 경우 적합

**전략 B: 참조 구현**
- Figma를 가이드라인으로만 참조
- 기존 UI 라이브러리 우선 활용
- 빠른 개발이 필요한 경우 적합

**전략 C: 하이브리드**
- 핵심 컴포넌트는 정밀 변환
- 일반 요소는 라이브러리 활용
- 균형 잡힌 접근 방식
